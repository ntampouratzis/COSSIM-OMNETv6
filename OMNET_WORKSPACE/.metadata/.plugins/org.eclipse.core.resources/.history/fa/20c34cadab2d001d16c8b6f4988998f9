/* ----------------------------------------------------------------------------
 * COSSIM - HLANode
 * Copyright (c) 2018, H2020 COSSIM.
 * Copyright (c) 2018, Telecommunications Systems Institute.
 * 
 * Author: Nikolaos Tampouratzis, ntampouratzis@isc.tuc.gr
 * ----------------------------------------------------------------------------
 *
*/


#include "Txc.h"
#include "testPacket_m.h"


using namespace std;
using namespace inet;


namespace HLANode {


uint16_t NetIpChecksum(uint16_t  ipHeader[], int nWords)
{
    uint32_t  sum = 0;// it should be uint32_t i guess
/*      * IP headers always contain an even number of bytes.      */
 while (nWords-- > 0)     {         sum += *(ipHeader++);     }
 /*      * Use carries to compute 1's complement sum.      */
sum = (sum >> 16) + (sum & 0xFFFF);     sum += sum >> 16;
 /*      * Return the inverted 16-bit result.      */
return ((uint16_t) ~sum);
}   /* NetIpChecksum() */




void SyncNode::HLANodesInitialization(cModule *parent){
    char str[20];
    for (int i=0;i<NUMBER_OF_HLA_NODES;i++){
        //!Initialize the HLA enable NODES !//
        sprintf(str, "node%d", i);
        Txc0* TX = (Txc0*)parent->getSubmodule(str);
#ifndef NO_HLA
        TX->HLA_initialization(NUMBER_OF_HLA_NODES);
#endif
    }
}

void SyncNode::HLANodesFinalization(cModule *parent){

    char str[20];
    for (int i=0;i<NUMBER_OF_HLA_NODES;i++){
        //!Finalize the HLA enable NODES !//
        sprintf(str, "node%d", i);
        Txc0* TX = (Txc0*)parent->getSubmodule(str);
#ifndef NO_HLA
        if(!TX->TerminateNormal)
            TX->NODEHLA->resign();
#endif
    }
}

void SyncNode::initialize(void) {

    NUMBER_OF_HLA_NODES = (int)par("NumberOfHLANodes");
    SYNCH_TIME          = (double)par("SynchTime");

    cMessage* event = new cMessage("reloop");

    scheduleAt(simTime()+SYNCH_TIME, event);

    //! Initialize the SynchNode !//
    HLA_initialization();

    //! initialize the HLA enable nodes !//
    cModule *parent= getParentModule();
    HLANodesInitialization(parent);
#ifndef NO_HLA
    //! As last step, synchronize the SynchNode!//
    HLAGlobalSynch->ReadGlobalSynch("GLOBAL_SYNCHRONIZATION");
#endif
}


void SyncNode::HLA_initialization(void) {
    string fedfile = "Federation.fed";
    string Synchfederation = "GLOBAL_SYNCHRONIZATION" ;
#ifndef NO_HLA
    HLAGlobalSynch = new HLA_OMNET(federate, NUMBER_OF_HLA_NODES,NUMBER_OF_HLA_NODES);
    HLAGlobalSynch->HLAInitialization(Synchfederation,fedfile, true, true);
#endif
    TerminateNormal = false;

    cout <<"\n--------------------  HLA SyncNode initialized"<<"\n";

}
void SyncNode::handleMessage(cMessage *msg){
#ifndef NO_HLA
    if(HLAGlobalSynch->ReadInFinalizeArray()){
        cout<<"Terminate the HLA Synchronization Node\n";
        HLAGlobalSynch->resign();
        TerminateNormal = true;
		endSimulation();
    }
    else{
        cMessage* event = new cMessage("syncstep");
        scheduleAt(simTime()+SYNCH_TIME, event);
        if (msg->isSelfMessage()) {
            HLAGlobalSynch->step();
        }
    }
#endif
}



#ifdef DEBUG_MSG
//-------------------------CRC stuff
void Txc0::CRC_Init()
{
    unsigned short remainder;

    for (int dividend = 0; dividend < 256; ++dividend)
    {
        remainder = dividend;

        for (uint8_t bit = 8; bit > 0; --bit)
        {
            if (remainder & 1)
                remainder = (remainder >> 1) ^ POLYNOMIAL;
            else
                remainder = (remainder >> 1);
        }

        crcTable[dividend] = remainder;
    }
}

unsigned short Txc0:: CRC_Calculate(const uint8_t *message, int nBytes)
{
    uint8_t data;
    unsigned short remainder=0;

    for (int byte = 0; byte < nBytes; ++byte)
    {
        data = message[byte] ^ remainder;
        remainder = crcTable[data] ^ (remainder >> 8);
    }

    return remainder;
}

//-----------------------end CRC stuff
#endif

void Txc0::setPayloadArray(inet::testPacket *msg, uint8_t *payload, int length)
{
    for (int i=0;i<length;i++) msg->setPayload(i, (uint8_t) payload[i]);
}
void Txc0::setPayloadArray2(inet::Ptr<testPacket> msg, uint8_t *payload, int length)
{
#ifdef DEBUG_MSG_ReceiveSide
         EV<< endl;
         EV<< "-------------SetPayloadArray2 Info-----------------" << endl;
         EV<< "msg = " << msg << endl;
         EV<< "msg->getDestAddress() = " << msg->getDestAddress() << endl;
         EV<< "-----------End of SetPayloadArray2 Info-----------------" << endl;
         EV<< endl;
#endif
    for (int i=0;i<length;i++) msg->setPayload(i, (uint8_t) payload[i]);
}

void Txc0::getPayloadArray(inet::testPacket * msg, uint8_t *payload, int length)      // const inet::Ptr<const inet::testPacket>
{
    for (int i=0;i<length;i++) payload[i]= msg->getPayload(i);
}

void Txc0::getPayloadArray2(const Ptr<const inet::testPacket>  msg, uint8_t *payload, int length)
{

#ifdef DEBUG_MSG_ReceiveSide
         EV<< endl;
         EV<< "-------------getPayloadArray2 Info-----------------" << endl;
         EV<< "msg = " << msg << endl;
         EV<< "msg->getDestAddress() = " << msg->getDestAddress() << endl;
         EV<< "-----------End of getPayloadArray2 Info-----------------" << endl;
         EV<< endl;
#endif
    for (int i=0;i<length;i++) payload[i]= msg->getPayload(i);
}

/*
void Txc0::sendCopyOf(testPacket* msg)
{
    //Duplicate message and send the copy.
    cMessage *copy = (cMessage *) msg->dup();
    send(copy, "gate$o");
}
*/

void Txc0::sendCopyOf2(inet::Ptr<testPacket> msg)
{
    //Duplicate message and send the copy.
    cMessage *copy = (cMessage *) msg->dup();
#ifdef DEBUG_MSG_ReceiveSide
         EV<< endl;
         EV<< "-------------sendCopyOf2 Info-----------------" << endl;
         EV<< "msg = " << msg << endl;
         EV<< "msg->getDestAddress() = " << msg->getDestAddress() << endl;
         EV<< "copy = " << copy << endl;
         EV<< "-----------End of sendCopyOf2 Info-----------------" << endl;
         EV<< endl;
#endif
    send(copy, "gate$o");
}

void Txc0::HLA_initialization(int _NUMBER_OF_HLA_NODES) {

    //! -------------- NODE HLA INITIALIZATION -------------- !//
    NUMBER_OF_HLA_NODES = _NUMBER_OF_HLA_NODES;
    federationName = "COSSIM_PROC_NET_NODE" + std::to_string(NODE_NO);
    string fedfile = "Federation.fed";
    TerminateNormal = false;
#ifndef NO_HLA
    NODEHLA = new HLA_OMNET(federate,NODE_NO,NUMBER_OF_HLA_NODES);
    NODEHLA->HLAInitialization(federationName,fedfile, false, false);

    //! -------------- END HLA INITIALIZATION -------------- !//

    cout <<"\n--------------------"<<"For NODE:"<<NODE_NO<< " HLA initialized"<<"\n";
#endif
}



void Txc0::initialize()

{
    char str[20];
    total_bytes_sent=0;
    total_bytes_received=0;
    NODE_NO = (int)par("nodeNo");
    RX_PACKET_TIME = (double)par("RXPacketTime");
    sprintf(str, "Txc%dreloop", NODE_NO);
    cMessage* event = new cMessage(str);
    scheduleAt(simTime()+RX_PACKET_TIME, event);
}



void Txc0::finish()
{

    cModule *parent= getParentModule();
#ifndef NO_HLA
    SyncNode* GEM5SyncNode =  (SyncNode*)parent->getSubmodule("syncnode");
    if(!GEM5SyncNode->TerminateNormal){

        cout<<"FINISH THE OMNET++ EXECUTION IN NODE: "<<NODE_NO<<"\n";

        //!Notify the SynchNode that this HLA node has been deleted !//

        GEM5SyncNode->HLAGlobalSynch->WriteInFinalizeArray(NODE_NO);

        //! Send Empty message to notify the OMNET++ termination !//
        if(!TerminateNormal){
            NODEHLA->sendInteraction(NULL,(uint32_t)0);
            NODEHLA->step(); // <-- Call with the sendInderaction
        }


        if(NODE_NO == NUMBER_OF_HLA_NODES-1){
            GEM5SyncNode->HLAGlobalSynch->step();
            GEM5SyncNode->HLAGlobalSynch->step();

            //! Finalize HLAEnableNodes !//
            GEM5SyncNode->HLANodesFinalization(parent);

            if(GEM5SyncNode->HLAGlobalSynch->ReadInFinalizeArray()){
                cout<<"Terminate the HLA Synchronization Node\n";
                GEM5SyncNode->HLAGlobalSynch->resign();
            }
            else{
                cout<<"Goes something wrong with HLA Termination! PLEASE RESTART THE rtig SERVER BEFORE THE NEXT EXECUTION !!!\n";
            }
        }
    }
#endif

    float bw=(total_bytes_sent/1024)/simTime();
    recordScalar("#Total Bytes Sent", total_bytes_sent);
    recordScalar("#total Bytes Received", total_bytes_received);
    recordScalar("#Simulation Time (sec)", simTime());
    recordScalar("#Bw sent utilization in KBytes per sec",bw );


}



void Txc0::handleMessage(cMessage *msg)
{

     if (msg->isSelfMessage()) {
         cMessage* event = new cMessage("reloop");
         scheduleAt(simTime()+RX_PACKET_TIME, event);

         //---------------Receive packet from GeM5--------------------------
#ifdef NO_HLA
         if(TOGGLE){
             TOGGLE=!TOGGLE;

          EtherTestPacket *Rcvpacket = new EtherTestPacket; //Initialize test packet

#else
       NODEHLA->step();

       if(!NODEHLA->BufferPacketEmpty()){

           EthPacketPtr Rcvpacket = NODEHLA->getPacket();
#ifdef DEBUG_MSG_ReceiveSide
         EV<< endl;
         EV<< "-------------Rcvpacket Info-----------------" << endl;
         EV<< "Rcvpacket = " << Rcvpacket << endl;
         EV<< "Rcvpacket->length() = " << Rcvpacket->length << endl;
         for(unsigned i = 0; i< Rcvpacket->length;)
         EV<< "-----------End of sendCopyOf2 Info-----------------" << endl;
         EV<< endl;
#endif
#endif
             /* ------- Rcvpacket is the Ethernet packet which we get from GEM5 ------- */

#ifdef DEBUG_MSG
             cout << "\n "<<"Node:"<< NODE_NO<<" Receive REAL Packet from GeM5 with length (integer print):"<< Rcvpacket->length<<"\n";
             for(unsigned i=0;i<Rcvpacket->length;i++){
                 cout<<(int)Rcvpacket->data[i]<<" ";
             }
             cout<<"\n";
#endif


             //------- Encapsulate Message for OMNET----------
             if (Rcvpacket->length > 0){ //! Receive Real Packet !//
                // myPacket *msg_gem5 =  new myPacket("fromGEM");
                 auto msg_gem5 = makeShared<testPacket>();

                 //testPacket *msg_gem5 = new testPacket();

                 msg_gem5->setName("fromGEM");
                 msg_gem5->setLength((unsigned int)Rcvpacket->length);
                 setPayloadArray2(msg_gem5, Rcvpacket->data, Rcvpacket->length);

#ifndef NO_HLA
                 NODEHLA->clearRcvPacket();
#endif
                 //! -------------- Testing Ethernet -------------- !//

                 // old-> inet::EthernetIIFrame *eth2Frame=0;
                 // old -> eth2Frame = new EthernetIIFrame();


                inet::Packet *packet = new Packet("packet",IEEE802CTRL_DATA);



                MacAddress sourceMac;   //old -> MACAddress sourceMac;
                MacAddress destMac;     //old -> MACAddress destMac ;

                for (int i=0;i<6;i++) tmp_dst[i]=(unsigned char)Rcvpacket->data[i];
                for (int i=0;i<6;i++) tmp_src[i]=(unsigned char)Rcvpacket->data[i+6];
                tmp_ethertype = (int) ((Rcvpacket->data[12] << 8) + (Rcvpacket->data[13] & 0xFF)  );//-1000000; // 12-13 bits are ethertype bits


                sourceMac.setAddressBytes(tmp_src);
                destMac.setAddressBytes(tmp_dst);




                auto ethHeader = makeShared<EthernetMacHeader>();
                //ethHeader->enableImplicitChunkSerialization = true;
                ethHeader->setDest(destMac);
                ethHeader->setSrc(sourceMac);
                ethHeader->setTypeOrLength(tmp_ethertype);
                packet->insertAtFront(ethHeader);
/*

                auto ethPhyHeader = makeShared<EthernetPhyHeader>();
                //ethPhyHeader->enableImplicitChunkSerialization = true;
                packet->insertAtFront(ethPhyHeader);
*/

#ifdef DEBUG_MSG_ReceiveSide
         EV<< endl;
         EV<< "-------------EthHeader Info Send Side-----------------" << endl;

         EV<< "EthHeader = " << ethHeader << endl;
         EV<< "ethHeader Source= " << ethHeader->getSrc() << endl;
         EV<< "ethHeader Dest = " << ethHeader->getDest() << endl;
         EV<< "ethHeader  TypeLength = " << ethHeader->getTypeOrLength() << endl;

         EV<< "-----------End of ethHeader Info Send Side-----------------" << endl;
         EV<< endl;
#endif

                 auto macAddressInd = packet->addTagIfAbsent<MacAddressInd>();
                 macAddressInd->setSrcAddress(ethHeader->getSrc());
                 macAddressInd->setDestAddress(ethHeader->getDest());

/*
 *
 *              idk if this needs
 *
                auto ethernetFcs = makeShared<EthernetFcs>();
                ethernetFcs->setFcsMode(FCS_DECLARED_CORRECT);
                //ethernetFcs->enableImplicitChunkSerialization = true;
                packet->insertAtBack(ethernetFcs);
*/
/*
 *                  this is not needed!
 *
                auto packetProtocolTag = packet->addTagIfAbsent<PacketProtocolTag>();
                packetProtocolTag->setProtocol(&Protocol::ethernetMac); // set protocol of packet
*/

                 auto tmp_packet = makeShared<testPacket>();
                 //testPacket *tmp_packet = new testPacket();
                 //tmp_packet->enableImplicitChunkSerialization = true;
                 // myPacket *tmp_packet= new myPacket("tmp_packet");
                 unsigned int tmp_packet_length=(unsigned int) (Rcvpacket->length-14);
                 tmp_packet->setLength(tmp_packet_length); //only the payload after striping dst, src, ethertype



                total_bytes_sent=total_bytes_sent+tmp_packet_length;

                for (unsigned int i=0;i<tmp_packet_length;i++) tmp_payload[i]= (uint8_t)Rcvpacket->data[i+14];
#ifdef DEBUG_MSG
                //DEBUG
                cout<<"\n DEBUG: From Node:"<< NODE_NO <<"  From Gem to Omnet, ethernet only payload(integer print):"<<"With packet length:"<<tmp_packet_length<<". ";
                for(unsigned i=0;i<tmp_packet_length;i++) cout<<(int) tmp_payload[i]<<" ";
                cout<<"\n";
                cout<<"\n DEBUG: From Node:"<< NODE_NO <<"  From Gem to Omnet, ethertype (hex print): "<<hex<<(int) (Rcvpacket->data[12]) <<","<< hex<<(int)(Rcvpacket->data[13]) <<". ";
                cout.unsetf(ios::hex);
#endif
                //ETHER_MAC_FRAME_BYTES setByteLength()
                setPayloadArray2(tmp_packet, tmp_payload, tmp_packet_length);
                tmp_packet->setChunkLength(b(ETHER_MAC_HEADER_BYTES));  //ETHER_MAC_HEADER_BYTES = 112 bits (14 bytes * 8 bit)
                //ETHER_MAC_FRAME_BYTES -> 18 bytes


                // --------------- Ethernet (L2) Routing ---------------
                if (L2_Routing) {
                    send_packet=true;
                    //packet->insertData((const Ptr<const inet::Chunk>)tmp_packet); , packet->insertAtBack((const Ptr<const inet::Chunk>)tmp_packet);
                    packet->insertAtBack(tmp_packet);     // if i do insertData(..) the header is not EthernetMacHeader (i dont know why)

                }

                //--------------- IPv4 (L3) Routing ---------------
                else if ((Rcvpacket->data[13]==0x00) and (Rcvpacket->data[12]==0x08) and  Rcvpacket->length>35){
                    send_packet=true;
                    EV<< " //--------------- IPv4 (L3) Routing ---------------"<< endl;



#ifdef DEBUG_MSG
                    cout<<"\n From Gem to Omnet: Got IP packet from GEM5 "<<" Node:"<< NODE_NO <<"\n";
                    //---------------IP Decaps----------------------------------------

                    cout<<"\n From Gem to Omnet: IP Starting parsing (reported from NODE:):"<< NODE_NO <<"\n";
                    cout<<"\n From Gem to Omnet: Packet length is (reported from NODE:):"<< (int)Rcvpacket->length<< NODE_NO  <<"\n";
#endif

                    //--------------- IP Decapsulation ---------------


                    my_Version=(short)  (Rcvpacket->data[14]<< 8);
                    my_IHL=(B) (Rcvpacket->data[14]& 0xFF);
                    my_TOS=(unsigned char) Rcvpacket->data[15];


                    my_Total_Length=(B) ((Rcvpacket->data[17] << 8) + (Rcvpacket->data[16] & 0xFF));
                    my_Identification=(int) ((Rcvpacket->data[19] << 8) + (Rcvpacket->data[18] & 0xFF));


                    my_Flags_DF=(bool)Rcvpacket->data[20] & 0x02;
                    my_Flags_MF=(bool)Rcvpacket->data[20] & 0x04;
                    my_Fragment_Offset=(int) ((Rcvpacket->data[21] << 5) + (Rcvpacket->data[20]>>3  & 0x1F)); //31



                    my_Time_to_Live= (short) Rcvpacket->data[22];
                                    // 6
                    my_Protocol= IP_PROT_TCP ;  // old -> (int)6// Rcvpacket->data[23]; //try 6 suppress the icmp casting error in wireless routers


                    for (int i=0;i<2;i++)my_Header_Checksum[i]=(unsigned char)Rcvpacket->data[i+24];

                    for (int i=0;i<4;i++)my_source_ip[i]=(int) Rcvpacket->data[i+26];
                    for (int i=0;i<4;i++)my_dest_ip[i]=(int) Rcvpacket->data[i+30];

#ifdef DEBUG_MSG
                    //for (int i;i<tmp_packet_length-35;i++)IP_data[i]=(unsigned char)Rcvpacket->data[i+35];
                    cout<<"\n From Gem to Omnet: IP parsing Starting... (reported from NODE:):"<< NODE_NO <<"\n";
                    cout<<"\n From Gem to Omnet: Source IP:";
                    for (int i=0;i<4;i++) cout<< (int)my_source_ip[i];
                    cout <<"\n From Gem to Omnet: Destination IP:";
                    for (int i=0;i<4;i++) cout<< (int)my_dest_ip[i];
                    cout<<"\n From Gem to Omnet: IP parsing complete. (reported from NODE:):"<< NODE_NO <<"\n";
#endif

                    //--------------- END IP Decapsulation ---------------

                    //----------------- Build Datagram ------------

                    datagramData = new Ipv4Header();    // old -> datagram= new IPv4Datagram("test");
                    icmp = new IcmpHeader();        //old -> icmp = new ICMPMessage("test");
                    //auto datagramData = makeShared<Ipv4Header>();
                    //auto datagramPacket = new Packet("DataGram", datagramData);
                    //auto icmp = makeShared<IcmpHeader>();


                    datagramData->setTotalLengthField(ETHER_MAC_HEADER_BYTES);     // old -> datagram->setByteLength(IP_HEADER_BYTES);
                    // old -> datagram->encapsulate(tmp_packet); //transportPacket for us is the ethernet payload


                    Ipv4Address IP_src,IP_dest;
                    // inet/src/inet/networklayer/contract/ipv4/IPv4Address.cc
                    IP_src.set(my_source_ip[0],my_source_ip[1],my_source_ip[2],my_source_ip[3]);
                    IP_dest.set(my_dest_ip[0],my_dest_ip[1],my_dest_ip[2],my_dest_ip[3]);

                    //------ set datagram ---
                    datagramData->setVersion(my_Version);   //old -> datagram->setVersion(my_Version);
                    datagramData->setHeaderLength(my_IHL);  //old -> datagram->setHeaderLength(my_IHL);
                    datagramData->setTypeOfService(my_TOS); //old -> datagram->setTypeOfService(my_TOS);
                    datagramData->setTotalLengthField(my_Total_Length); //old -> datagram->setTotalLengthField(my_Total_Length);
                    datagramData->setIdentification(my_Identification); //old -> datagram->setIdentification(my_Identification);

                    datagramData->setDontFragment(my_Flags_DF); //old -> datagram->setDontFragment(my_Flags_DF); // bit 2/8
                    datagramData->setMoreFragments(my_Flags_MF); //old -> datagram->setMoreFragments(my_Flags_MF); //bit 3/8
                    datagramData->setFragmentOffset(my_Fragment_Offset); //old -> datagram->setFragmentOffset(my_Fragment_Offset);// bits: 4,5,6,7,8 + 8 = 13 bits
                    datagramData->setTimeToLive(my_Time_to_Live); //old -> datagram->setTimeToLive(my_Time_to_Live);

                    datagramData->setProtocolId(my_Protocol); //old -> datagram->setProtocolId(my_Protocol);   //old -> datagram->setTransportProtocol(my_Protocol);

                    //Header Checksum omitted, modeled by error bit of packets

                    datagramData->setSrcAddress(IP_src);    //old -> datagram->setSrcAddress(IP_src);
                    datagramData->setDestAddress(IP_dest);  //old -> datagram->setDestAddress(IP_dest);
                    datagramData->setTotalLengthField(ETHER_MAC_HEADER_BYTES);  //old -> datagram->setTotalLengthField(ETHER_MAC_HEADER_BYTES);      //old ->datagram->setTotalLengthField(IP_HEADER_BYTES);

                    /*
                     *  old
                     *
                     *  inet::Ieee802Ctrl *etherctrl;
                     *  etherctrl = new Ieee802Ctrl();
                     *  etherctrl->setSrc(sourceMac);
                     *  etherctrl->setDest(destMac);
                     *  etherctrl->setEtherType(tmp_ethertype);
                     *
                     *  need to be fixed!
                    */

                    auto macAddressInd = packet->addTagIfAbsent<MacAddressInd>();
                    macAddressInd->setSrcAddress(ethHeader->getSrc());
                    macAddressInd->setDestAddress(ethHeader->getDest());


                    // PRId64 -> uint64_t
                    if (datagramData->getTotalLengthField() > MAX_ETHERNET_DATA_BYTES)
                        throw cRuntimeError("packet from higher layer (%" PRId64 " bytes) exceeds maximum Ethernet payload length (%" PRId64 ")",datagramData->getTotalLengthField(), MAX_ETHERNET_DATA_BYTES);
                    //eth2FramePacket->encapsulate(datagramPacket);

                    //eth2FramePacket->insertData(datagramData);

#ifdef DEBUG_MSG
                    cout<<"\n From Gem to Omnet: Datagram Encapsulated! (reported from NODE:):"<< NODE_NO <<"\n";
#endif
                }

                //--------------- IPv6 (L3) Routing (Not supported) ---------------
                else if ((Rcvpacket->data[13]==0xdd) and (Rcvpacket->data[12]==0x86)){
                    //IPV6 packet, don't send it
                    send_packet=false;
                   //EV<< "//--------------- IPv6 (L3) Routing (Not supported) ---------------"<< endl;
                }

                //--------------- ARP Request/Reply (L3) Routing ---------------
                else if ((Rcvpacket->data[13]==0x06) and (Rcvpacket->data[12]==0x08))
                {
#ifdef DEBUG_MSG
                    cout<<"\n From Gem to Omnet: Got ARP packet from GEM5 "<<" Node:"<< NODE_NO <<"\n";
#endif
                    ArpPacket* tmp_arp_packet  =new ArpPacket();//old -> ARPPacket* tmp_arp_packet  =new ARPPacket("MyARP_Packet");
                    //tmp_arp_packet->setName("GEM5_arp");
                    //Packet* tmp_arp_packet = new Packet();

                    //tmp_arp_packet->encapsulate(tmp_packet); //To make GEM5 decapsulation easier (OMNET don't need this)
                    //tmp_arp_packet->setByteLength(ARP_HEADER_BYTES);
                    //FIX accordingly
                    //20, 21 :ARP opcode
                    tmp_arp_packet->setOpcode((ArpOpcode) Rcvpacket->data[21]);
                    if (Rcvpacket->data[21]==2) ;//eth2FramePacket->setName("GEM5_arpREPLY");                // old -> tmp_arp_packet->setName("GEM5_arpREPLY");
                    else if (Rcvpacket->data[21]==1) ; //eth2FramePacket->setName("GEM5_arpREQUEST"); // old -> tmp_arp_packet->setName("GEM5_arpREQUEST");
#ifdef DEBUG_MSG
                    cout<<"\n  --------- tmp_arp_packet->setOpcod --------:"<< (int) Rcvpacket->data[21] <<"From Node: "<< NODE_NO <<"\n";
#endif


                    tmp_arp_packet->setDestMacAddress(destMac);  //same as Ethernet no need to parse it from ARP
                    tmp_arp_packet->setSrcMacAddress(sourceMac); //same as Ethernet no need to parse it from ARP

                    Ipv4Address IP_src,IP_dest;

                    // -------------Check Those:
                    for (int i=0;i<4;i++)my_source_ip[i]=(int) Rcvpacket->data[i+28];
                    for (int i=0;i<4;i++)my_dest_ip[i]=(int) Rcvpacket->data[i+38];

                    IP_src.set(my_source_ip[0],my_source_ip[1],my_source_ip[2],my_source_ip[3]);
                    IP_dest.set(my_dest_ip[0],my_dest_ip[1],my_dest_ip[2],my_dest_ip[3]);

#ifdef DEBUG_MSG
                    cout<<"\n From Gem to Omnet: ARP Source IP:";
                    for (int i=0;i<4;i++) cout<< (int)my_source_ip[i]<<".";
                    cout <<"\n From Gem to Omnet: ARP Destination IP:";
                    for (int i=0;i<4;i++) cout<< (int)my_dest_ip[i]<<".";
#endif
                    tmp_arp_packet->setDestIpAddress(IP_dest);  //old ->tmp_arp_packet->setDestIPAddress(IP_dest);
                    tmp_arp_packet->setSrcIpAddress(IP_src);    //old -> tmp_arp_packet->setSrcIPAddress(IP_src);

                    //eth2FramePacket->encapsulate(tmp_arp_packet->getp);///was tmp_packet
                    send_packet=true;

                    EV << "//--------------- ARP Request/Reply (L3) Routing --------------- " << endl;



                }

                else{ //Handle packet as raw payload
                    //eth2FramePacket->encapsulate(tmp_packet);///was tmp_packet
#ifdef DEBUG_MSG
                     cout<<"\n From Gem to Omnet: tmp_packet Encapsulated! (reported from NODE:):"<< NODE_NO <<"\n";
#endif
                     send_packet=true;
                     EV << "//Handle packet as raw payload  " << endl;

                }
                //EV<< "eth2FramePacket->getByteLength() = " << eth2FramePacket->getByteLength() << endl;

                //End of Protocol cases
                int64_t min_ethernet_frame_bytes = 64;  //MIN_ETHERNET_FRAME_BYTES
                if(packet->getTotalLength() <  b(min_ethernet_frame_bytes)){
                    // MIN_ETHERNET_FRAME_BYTES = B(64);
                    packet->setByteLength(min_ethernet_frame_bytes); // "padding"
                    EV<< "padding = "<< packet->getByteLength()<< endl;

                }





                if (send_packet){
#ifdef DEBUG_MSG
                    cout<<"\n  ---------Sending Packet through OMNET NETWORK---------:"<<"From Node: "<< NODE_NO <<"\n";
#endif

                    /* old
                    EV<< "send_packet = "<< send_packet<<endl;
                    EthPhyFrame = new EtherPhyFrame();
                    EthPhyFrame->setSrcMacFullDuplex(true);
                    EthPhyFrame->encapsulate(eth2Frame);
                    send(EthPhyFrame, "gate$o");
                    */
                    /*
                     *  This is for switch
                     * */
                   // inet::physicallayer::Signal *singal = new Signal();
                   // singal->encapsulate(packet);
                    /*
                    inet::physicallayer::EthernetSignal *ethernetSingal = new EthernetSignal();
                    ethernetSingal->setSrcMacFullDuplex(true);
                    ethernetSingal->encapsulate(packet);
*/

                    send(packet,"gate$o");
                }
#ifdef DEBUG_MSG
                else  cout<<"\n  --------- Packet NOT SENT! (probably IPV6 packet) through OMNET NETWORK---------:"<<"From Node: "<< NODE_NO <<"\n";
#endif
                //! -------------- Testing Ethernet -------------- !//

             }
             else{ //! Receive Empty Packet -- Terminate the HLA Connection !//
#ifdef DEBUG_MSG
                 cout<<"\nNode:"<< NODE_NO<<" Terminate HLA Connection\n";
#endif

#ifndef NO_HLA
                 NODEHLA->clearRcvPacket();
                 NODEHLA->resign();

                 cancelEvent(event);

                 //!Notify the SynchNode that this HLA node has been deleted !//
                 cModule *parent= getParentModule();
                 SyncNode* GEM5SyncNode =  (SyncNode*)parent->getSubmodule("syncnode");
                 GEM5SyncNode->HLAGlobalSynch->WriteInFinalizeArray(NODE_NO);

                 TerminateNormal = true;
#endif
             }

            //-------END Encapsulate Message for OMNET----------
       }

     }
     else { //------- Receive real message from OMNET++ network (other OMNET++ node) -------
         bubble("-----just got a real message from OMNET++ network------");

#ifdef DEBUG_MSG
         cout<<"\n ---";
         cout<<"\n  ---------Receiving Packet from OMNET NETWORK---------:"<<"From Node: "<< NODE_NO <<"\n";
         cout<<"\n ---";
#endif
         TOGGLE=!TOGGLE;
         EV<< "//------- Receive real message from OMNET++ network (other OMNET++ node) " << endl;

         //EtherTraffic *msgTraffic = check_and_cast<EtherTraffic *>(msg);
         //EtherPhyFrame * etherPhyReceived = dynamic_cast<EtherPhyFrame *>(msgTraffic);
         //cPacket *frame_cPacket = etherPhyReceived->decapsulate();
         //EtherFrame *frame_received = check_and_cast<EtherFrame *>(frame_cPacket);
         //EtherFrame *eth2Frame2 = nullptr;

         // This is for Switch


       // inet::EthernetMacHeader *ethernetMacHeaderReceived = check_and_cast<EthernetMacHeader *> (msg);
        //inet::physicallayer::EthernetPhyHeader * ethernetPhyHeaderReceived = dynamic_cast<EthernetPhyHeader *> (ethernetMacHeaderReceived);
        // auto etherSingalReceive = check_and_cast<EthernetSignal * >(msg);

/*
         inet::Ptr<const EthernetSignal> etherSingalReceive;
         if(dynamicPtrCast<const EthernetSignal>(msg)){
             etherSingalReceive = check_and_cast<EthernetSignal * >(msg);
             EV<< "YESSSS" << endl;
         }
         */

        //inet::physicallayer::EthernetSignal *etherSingalReceive = dynamic_cast<EthernetSignal * >(msg);
        //inet::physicallayer::EthernetPhyHeader * ethernetPhyHeaderReceived = dynamic_cast<EthernetPhyHeader *> (etherSingalReceive);
        //cPacket *frame_cPacket = etherSingalReceive->decapsulate();

        //inet::physicallayer::EthernetPhyHeader *ethernetPhyHeaderReceived = dynamic_cast<EthernetPhyHeader *> (etherSingalReceive);

        //inet::physicallayer::Signal *SingalReceive = check_and_cast<Signal * >(msg);
         //inet::cPacket *Cpacket = etherSingalReceive->decapsulate();




         inet::Packet *receivedPacket = check_and_cast<Packet*>(msg);
         auto header = receivedPacket->peekAtFront();   // use peek not pop because pop need seriliazetion!

#ifdef DEBUG_MSG_ReceiveSide
         EV<< endl;
         EV<< "-----------Packet Info-----------------" << endl;

         EV<< "PACKET = " << receivedPacket << endl;
         EV<< "PACKET Path = " << receivedPacket->getFullPath() << endl;
         EV<< "PACKET NAME = " << receivedPacket->getName()<< endl;

         EV<< "-----------End Packet Info-----------------" << endl;
         EV<< endl;
#endif

         inet::Packet *packet2 = new Packet("packet2",IEEE802CTRL_DATA);
         inet::Ptr<const inet::EthernetMacHeader> ethernetMacHeader;



         if (dynamicPtrCast<const EthernetMacHeader>(header)) { // check if the header type is correct
#ifdef DEBUG_MSG_ReceiveSide
             EV<< endl;
             EV<< "Inside of DynamicPtrCast EthernetMacHeader" <<endl;
             EV<< endl;
#endif

             //inet::Packet *ethPacket = new Packet("ethPacket" ,IEEE802CTRL_DATA);
             //ethPacket = (Packet*)(msg);

             ethernetMacHeader = receivedPacket->peekAtFront<EthernetMacHeader>();
             ethertype = ethernetMacHeader->getTypeOrLength();
             packet2 = receivedPacket;
             ethertype_dec[0] = (uint8_t) ((ethertype  >> 8) & 0xFF);
             ethertype_dec[1] = (uint8_t)(ethertype  & 0xFF);


#ifdef DEBUG_MSG_ReceiveSide
         EV<< "-----------Packet2 Info-----------------" << endl;
         EV<< "PACKET2 = " << packet2 << endl;
         EV<< "PACKET Path2 = " << packet2->getFullPath() << endl;
         EV<< "PACKET NAME2 = " << packet2->getName()<< endl;
         EV<< "Header src = " << ethernetMacHeader->getSrc() << endl;
         EV<< "Header dest = " << ethernetMacHeader->getDest() << endl;
         EV<< "-----------End Packet2 Info-----------------" << endl;
#endif

         }

        else if(dynamicPtrCast<const Ieee8022LlcSnapHeader>(header)){
#ifdef DEBUG_MSG_ReceiveSide
            EV<< endl;
            EV<< "Inside of DynamicPtrCast Ieee8022LlcSnapHeader" <<endl;
            EV<< endl;
#endif
             EV<< "Ieee8022LlcSnapHeader"<< endl;
             cout<<"\n EtherFrameWithSNAP taken";
             //auto ieee = receivedPacket->popAtFront();
             Ieee8022LlcSnapHeader  *snapFrame = new Ieee8022LlcSnapHeader();
             snapFrame =(Ieee8022LlcSnapHeader*)(msg);
             snap_local_code=snapFrame->getProtocolId();

             packet2=(Packet*)snapFrame;
#ifdef DEBUG_MSG
             cout<<"\n From OMNET to GEM5: Decoding Ethernet:"<<"From Node: "<< NODE_NO <<" Ethernet packet Name: "<<packet2->getName() <<" "<<"\n";
#endif
             ethertype_dec[0]=(uint8_t) ((ethertype  >> 8) & 0xFF);
             ethertype_dec[1]=(uint8_t)(ethertype  & 0xFF);
         }

         /*
          * old
         MacAddress sourceMac = eth2Frame2->getSrc();   unsigned char tmp_src[6];
         MacAddress destMac   = eth2Frame2->getDest();  unsigned char tmp_dst[6];

         sourceMac.getAddressBytes(tmp_src);
         destMac.getAddressBytes(tmp_dst);
         */



         MacAddress sourceMac = ethernetMacHeader->getSrc();   unsigned char tmp_src[6];
         MacAddress destMac   = ethernetMacHeader->getDest();  unsigned char tmp_dst[6];

         sourceMac.getAddressBytes(tmp_src);
         destMac.getAddressBytes(tmp_dst);

         /*
         if(ethernetMacHeader != nullptr){
             MacAddress sourceMac = ethernetMacHeader->getSrc();   unsigned char tmp_src[6];
             MacAddress destMac   = ethernetMacHeader->getDest();  unsigned char tmp_dst[6];

             sourceMac.getAddressBytes(tmp_src);
             destMac.getAddressBytes(tmp_dst);
         }
         */

#ifdef DEBUG_MSG
         cout<<"\n From OMNET to GEM5: for packet type: From Node:"<< NODE_NO <<" ethertype_dec[0],[1]:" <<(int)ethertype_dec[0]<<","<< (int)ethertype_dec[1]<<".  ";
         cout<<"\n From OMNET to GEM5: IF for GEM5 valid packet taken ---------:"<<"From Node: "<< NODE_NO <<"\n";
#endif
         inet::Ptr<const Chunk> from_eth_packet_pt;


         //testPacket *from_eth_packet_pt;

         //const Ptr<const inet::testPacket> from_eth_packet_pt;

         //const Ptr<const inet::testPacket> testPacketReceived;

         //const Ptr<const inet::testPacket> from_eth_packet_pt;
         unsigned int from_eth_payload_length;

         // --------------- Ethernet (L2) Routing ---------------
         if (L2_Routing) {
             EV<< "Inside of if (L2_Routing)" << endl;

             from_eth_packet_pt = packet2->peekData();

             if(dynamicPtrCast<const testPacket>(from_eth_packet_pt)){
                 auto test = packet2->peekData<testPacket>();
                 auto from_eth_payload_length=test->getLength();
                 getPayloadArray2(test,from_eth_payload,from_eth_payload_length);
             }
        }

        //--------------- IPv4 (L3) Routing ---------------
        else if ((ethertype_dec[1]==0x00) and (ethertype_dec[0]==0x08) ){
#ifdef DEBUG_MSG
          cout<<"\n From OMNET to GEM5: Got IP packet from NETWORK From Node:"<< NODE_NO <<"\n";
#endif
          //EV<< "//------- else if ((ethertype_dec[1]==0x00) and (ethertype_dec[0]==0x08) ) " << endl;
          /*
           * old
          IPv4Datagram *my_datagram = (IPv4Datagram*) (eth2Frame2->decapsulate());

          from_eth_packet_pt=  (myPacket*) (my_datagram->decapsulate());
          from_eth_payload_length=from_eth_packet_pt->getLength();
          getPayloadArray(from_eth_packet_pt,from_eth_payload,from_eth_payload_length);
          */





#ifdef DEBUG_MSG
          //--------Testing IP Checksum--------
          //http://www.thegeekstuff.com/2012/05/ip-header-checksum

          uint16_t ip_header[10];
          for (int i=0;i<10;i++) ip_header[i]= (uint16_t) (  (from_eth_payload[i+1] <<8)  + (from_eth_payload[i] & 0xFF)) ;


          cout << "\n "<<"------> From OMNET to GEM5: Previous checksum result from  Node (hex print):" <<NODE_NO <<"="<< hex << (int)from_eth_payload[10] <<hex<< (int)from_eth_payload[11]<<"\n";
          cout.unsetf(ios::hex);
          cout << "\n "<<"------> From OMNET to GEM5: Previous checksum result from  Node (2 integers print):" <<NODE_NO <<"="<<   (int)from_eth_payload[10]  <<","<< (int)from_eth_payload[11]<<"\n";
          cout.unsetf(ios::hex);
          cout << "\n "<<"------> From OMNET to GEM5: Previous checksum result from  Node (single integer print from uint16_t..ip_header[5] ):" <<NODE_NO <<"="<<   (int)ip_header[5]    <<"\n";
          cout.unsetf(ios::hex);

          ip_header[5]= (uint16_t) 0; //zero old checksum before recompute

          uint16_t  myIP_checksum= NetIpChecksum(ip_header,10);
          uint8_t myIP_checksum_0= (uint8_t)myIP_checksum & 0xFF;
          uint8_t myIP_checksum_1= (uint8_t)myIP_checksum >>8 & 0xFF;

          cout << "\n "<<"------> From OMNET to GEM5: myIP_checksum result from  Node (two integers print):" <<NODE_NO <<"="<<  (int)myIP_checksum_0 << ","<< (int) myIP_checksum_1<<"\n";
          cout.unsetf(ios::hex);

          //---------End Testing IP Checksum--------
#endif

        }
        //--------------- IPv6 (L3) Routing (Not supported) ---------------
        else if ((ethertype_dec[1]==0xdd) and (ethertype_dec[0]==0x86)){ //We don't need this as this packet will never be sent from the other end
#ifdef DEBUG_MSG
          cout<<"\n From OMNET to GEM5: Got IPV6 packet do nothing from NETWORK From Node: "<< NODE_NO <<"\n";
#endif
          //IPV6 packet, don't send it
        }

        //--------------- ARP Request/Reply (L3) Routing ---------------
        else if ((ethertype_dec[1]==0x06) and (ethertype_dec[0]==0x08)){ //UNIVERSAL ARP request/Reply
#ifdef DEBUG_MSG
            cout<<"\n From OMNET to GEM5: Got ARP packet from NETWORK From Node: "<< NODE_NO <<"\n";
#endif
             // old -> string s = typeid(eth2Frame2->decapsulate()).name();
            //string s = typeid(packet2->decapsulate()).name();
#ifdef DEBUG_MSG
             //cout<<"\n From OMNET to GEM5: Got ARP packet from NETWORK From Node: "<< NODE_NO << "With class name:"<<s<<"\n";
#endif
            /* old
             ARPPacket* my_arp_packet  =(ARPPacket*) (eth2Frame2->decapsulate());
             //EV<< " //--------------- ARP Request/Reply (L3) Routing ---------------" << endl;
             MACAddress sourceMac;
             MACAddress destMac ;
             IPv4Address IP_src,IP_dest;

             sourceMac= my_arp_packet->getSrcMACAddress();
             destMac= my_arp_packet->getDestMACAddress();

             // inet/src/inet/networklayer/contract/ipv4/IPv4Address.cc
             IP_src= my_arp_packet->getSrcIPAddress();
             for (int i=0;i<4;i++) my_source_ip[i]= IP_src.getDByte(i);

             IP_dest= my_arp_packet->getDestIPAddress();
             for (int i=0;i<4;i++) my_dest_ip[i]= IP_dest.getDByte(i);

             int opcode=my_arp_packet->getOpcode();
            */

#ifdef DEBUG_MSG
             cout<<"\n From Omnet to Gem  : ARP Source IP:";
             for (int i=0;i<4;i++) cout<< (int)my_source_ip[i]<<".";
             cout <<"\n From Omnet to Gem  : ARP Destination IP:";
             for (int i=0;i<4;i++) cout<< (int)my_dest_ip[i]<<".";
#endif

             /* old
             //from_eth_payload,
             from_eth_payload_length=46; ///building raw arp packet for GEM
             //Serializing GEM5 compatible packet
             from_eth_payload[0]=(uint8_t) 0; //Hardware type (Ethernet)
             from_eth_payload[1]=(uint8_t) 1; //Hardware type (Ethernet)

             from_eth_payload[2]=(uint8_t) 8; //Protocol type (IP)
             from_eth_payload[3]=(uint8_t) 0; //Protocol type (IP)
             from_eth_payload[4]=(uint8_t) 6; //Hardware size
             from_eth_payload[5]=(uint8_t) 4; //Protocol size

             from_eth_payload[6]=(uint8_t) 0; //Opcode (reply)
             from_eth_payload[7]=(uint8_t) opcode; //Opcode (reply)

             for (int i=0;i<6;i++)  from_eth_payload[i+8]= (uint8_t)tmp_src[i]; //8-13: Source MAC address

             for (int i=0;i<4;i++)  from_eth_payload[i+14]= (uint8_t)my_source_ip[i]; //14-17

             for (int i=0;i<6;i++)  from_eth_payload[i+18]= (uint8_t)tmp_dst[i]; //18-23: Destination MAC address

             for (int i=0;i<4;i++)  from_eth_payload[i+24]= (uint8_t) my_dest_ip[i]; //24-27

             ///--------   Ending ARP ----------------

             for (int i=28;i<46;i++) from_eth_payload[i]=(uint8_t)0; //zero padding for the rest of the ethernet packet

             ethertype_dec[0]=(uint8_t)8; //Type for ARP protocol
             ethertype_dec[1]=(uint8_t)6; //Type for ARP protocol
             */

#ifdef DEBUG_MSG
             cout<<"\n";
             //cout<<"\n From OMNET to GEM5  : UNVERSAL ARP From Node: "<< NODE_NO << " opcode: "<<opcode<<"\n";
             cout<<"\n From Omnet to Gem5  : UNVERSAL ARP Source MAC:";
             for (int i=0;i<6;i++) cout<< (int)tmp_src[i] <<".";
             cout<<"\n From Omnet to Gem5  : UNVERSAL ARP Destination MAC:";
             for (int i=0;i<6;i++) cout<< (int)tmp_dst[i]<<".";
             cout<<"\n";
#endif
        }

        //------------------------------------END ADAPT ------------------------

        else
        {
#ifdef DEBUG_MSG
            cout<<"\n  From OMNET to GEM5: ---------Other type Decapsulated from OMNET NETWORK---------:"<<"From Node: "<< NODE_NO <<"\n";
#endif
            /* old
             *

            from_eth_packet_pt=   (myPacket*) (eth2Frame2->decapsulate());
            from_eth_payload_length=from_eth_packet_pt->getLength();
            getPayloadArray(from_eth_packet_pt,from_eth_payload,from_eth_payload_length);
            */

/*  this need to be fixed
 * */
            from_eth_packet_pt = packet2->peekData();
            if(dynamicPtrCast<const testPacket>(from_eth_packet_pt)){
                 auto test = packet2->peekData<testPacket>();
                 auto from_eth_payload_length=test->getLength();
                 getPayloadArray2(test,from_eth_payload,from_eth_payload_length);
             }


        }

#ifdef DEBUG_MSG
         cout<<"\n From OMNET to GEM5: DEBUG: From Node:"<< NODE_NO <<" Ethernet only payload (integer print):"<<"With payload length:"<<from_eth_payload_length<<". ";
         for(unsigned i=0;i<from_eth_payload_length;i++) cout<<(int) from_eth_payload[i]<<" ";
         cout<<"\n";
         //Logs
#endif

         total_bytes_received=total_bytes_received+from_eth_payload_length;

         //dest, src ethernet
         for (int i=0;i<6;i++) total_payload[i]=(uint8_t)tmp_dst[i];
         for (int i=0;i<6;i++) total_payload[i+6]=(uint8_t)tmp_src[i];
         //ethertype

         total_payload[12]= ethertype_dec[0];//(uint8_t)ethertype2    & 0xFF;
         total_payload[13]= ethertype_dec[1];//(uint8_t) (ethertype2>>8 & 0xFF);


         for (unsigned i=0;i<from_eth_payload_length;i++) total_payload[i+14]=(uint8_t)from_eth_payload[i];


#ifdef DEBUG_MSG
         cout << "\n "<<"------From OMNET to GEM5: Node:"<< NODE_NO<<" SEND Packet into GeM5 with total length:"<< (int)(from_eth_payload_length+14)<<"\n";
         for(unsigned i=0;i<from_eth_payload_length+14;i++){
           cout<<(int)total_payload[i]<<" ";
         }
         cout<<"\n";

         CRC_Init();
         unsigned short CRC_result= CRC_Calculate(total_payload, (int)from_eth_payload_length+14);
         cout << "\n "<<"From OMNET to GEM5: CRC result from  Node:(hex print)" <<NODE_NO <<"="<< hex <<CRC_result<<"\n";
         cout.unsetf(ios::hex);
#endif

#ifndef NO_HLA
        NODEHLA->sendInteraction(total_payload,from_eth_payload_length+14); //with ethernet support


        //NODEHLA->sendInteraction(payload_temp,length_temp);
        NODEHLA->step(); // <-- Call with the sendInderaction (GEM5 Send Function)
#endif

     }

}


Define_Module(Txc0);
Define_Module(SyncNode);

}; // end namespace

#ifdef NO_HLA
EtherTestPacket::EtherTestPacket(){
 // uint8_t data2[]={0,144,0,0,0,1,0,144,0,0,0,0,8,0,69,0,0,84,146,63,64,0,64,1,148,103,10,0,0,1,10,0,0,2,8,0,115,52,185,2,0,0,115,200,88,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
  //length=90;

   //uint8_t data2[]={255,255,255,255,255,255,0,144,0,0,0,0,8,6,0,1,8,0,6,4,0,1,0,144,0,0,0,0,10,0,0,1,0,0,0,0,0,0,10,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
   //length=60; //arp request packet packet, ethtype 8,6

   // uint8_t data2[]="\xff\xff\xff\xff\xff\xff\x00\x90\x00\x00\x00\x00\x08\x06\x00\x01\x08\x00\x06\x04\x00\x01\x00\x90\x00\x00\x00\x00\x0a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0a\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
    //length=60; //arp request packet packet, ethtype 8,6

    //uint8_t data2[]={0,144,0,0,0,1,0,144,0,0,0,0,8,0,69,0,0,84,146,63,64,0,64,1,148,103,10,0,0,1,10,0,0,2,8,0,115,52,185,2,0,0,115,200,88,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    //length=98; //IPV4 packet

    uint8_t data2[]={10,170,0,0,0,4,0,144,0,0,0,0,8,0,69,0,0,84,196,181,64,0,64,1,94,235,10,0,2,3,10,0,1,6,8,0,216,156,188,2,0,0,161,95,194,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    length=98;

  // int data2[]={51,51,0,0,0,2,0,144,0,0,0,1,134,221,96,0,0,0,0,16,58,255,254,128,0,0,0,0,0,0,2,144,0,255,254,0,0,1,255,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,133,0,122,12,0,0,0,0,1,1,0,144,0,0,0,1};
  //EtherTestPacket::length=70; // IPV6 packet, ethtype 86,dd

  data= new uint8_t[length];
  for (int i=0; i<length; i++) data[i]=(uint8_t)data2[i];
}
#endif



